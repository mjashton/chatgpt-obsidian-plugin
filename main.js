/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChatGPTToObsidianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultFolder: "ChatGPT",
  includeUserPrompts: true,
  includeTimestamps: true,
  includeTags: true,
  defaultTags: "chatgpt, ai"
};
function convertToMarkdown(content) {
  return content.replace(/\*\*(.*?)\*\*/g, "**$1**").replace(/\*(.*?)\*/g, "*$1*").replace(/`([^`]+)`/g, "`$1`").replace(/```([\s\S]*?)```/g, "```$1```");
}
var ChatGPTToObsidianPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.metadataStore = { qaPairs: {}, lastUpdated: Date.now() };
    this.METADATA_FILE_NAME = ".chatgpt-plugin-metadata.json";
  }
  async onload() {
    await this.loadSettings();
    await this.loadConversationMetadata();
    const ribbonIconEl = this.addRibbonIcon("message-square", "ChatGPT to Obsidian", (evt) => {
      new ChatGPTImportModal(this.app, this).open();
    });
    this.addCommand({
      id: "open-chatgpt-importer",
      name: "Import ChatGPT conversations",
      callback: () => {
        new ChatGPTImportModal(this.app, this).open();
      }
    });
    this.addSettingTab(new ChatGPTSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Parse ChatGPT conversations.json
  parseChatGPTData(jsonContent) {
    try {
      const data = JSON.parse(jsonContent);
      return data;
    } catch (error) {
      console.error("Error parsing ChatGPT data:", error);
      throw new Error("Invalid ChatGPT export format");
    }
  }
  // Extract clean conversation threads
  extractConversations(conversations) {
    return conversations.map((conv) => {
      var _a;
      const messages = [];
      const mapping = conv.mapping;
      let current = Object.values(mapping).find(
        (msg) => {
          var _a2, _b;
          return msg.message && msg.message.author.role === "user" && msg.parent && ((_b = (_a2 = mapping[msg.parent]) == null ? void 0 : _a2.message) == null ? void 0 : _b.author.role) === "system";
        }
      );
      while (current) {
        if (current.message && current.message.author.role !== "system") {
          const content = ((_a = current.message.content.parts) == null ? void 0 : _a.join("\n")) || "";
          if (content.trim()) {
            messages.push({
              role: current.message.author.role,
              content,
              timestamp: current.message.create_time || 0,
              id: current.id
            });
          }
        }
        current = current.children.length > 0 ? mapping[current.children[0]] : null;
      }
      return {
        title: conv.title,
        id: conv.id,
        create_time: conv.create_time,
        update_time: conv.update_time,
        messages
      };
    });
  }
  // Metadata management methods
  async loadConversationMetadata() {
    try {
      console.log("[METADATA DEBUG] Loading metadata from:", this.METADATA_FILE_NAME);
      let content;
      try {
        content = await this.app.vault.adapter.read(this.METADATA_FILE_NAME);
        console.log("[METADATA DEBUG] Successfully read metadata file via adapter");
      } catch (readError) {
        console.log("[METADATA DEBUG] Metadata file does not exist or cannot be read:", readError.message);
        this.metadataStore = { qaPairs: {}, lastUpdated: Date.now() };
        return;
      }
      const data = JSON.parse(content);
      console.log("[METADATA DEBUG] Parsed metadata JSON successfully");
      if (data.conversations) {
        console.log("[METADATA DEBUG] Migrating metadata from conversation-level to Q&A pair-level format");
        this.metadataStore = { qaPairs: {}, lastUpdated: Date.now() };
      } else if (data.qaPairs) {
        this.metadataStore = data;
        console.log("[METADATA DEBUG] Loaded Q&A pair metadata:", Object.keys(this.metadataStore.qaPairs).length, "pairs");
        console.log("[METADATA DEBUG] Sample pair IDs:", Object.keys(this.metadataStore.qaPairs).slice(0, 3));
      } else {
        console.log("[METADATA DEBUG] Unknown metadata format, starting fresh");
        this.metadataStore = { qaPairs: {}, lastUpdated: Date.now() };
      }
    } catch (error) {
      console.error("[METADATA DEBUG] Error loading Q&A pair metadata:", error);
      this.metadataStore = { qaPairs: {}, lastUpdated: Date.now() };
    }
  }
  async saveConversationMetadata() {
    try {
      this.metadataStore.lastUpdated = Date.now();
      const content = JSON.stringify(this.metadataStore, null, 2);
      console.log("[METADATA DEBUG] Saving metadata:", {
        fileName: this.METADATA_FILE_NAME,
        pairCount: Object.keys(this.metadataStore.qaPairs).length,
        contentLength: content.length
      });
      let fileExists = false;
      try {
        await this.app.vault.adapter.read(this.METADATA_FILE_NAME);
        fileExists = true;
        console.log("[METADATA DEBUG] File exists (detected via read)");
      } catch (readError) {
        console.log("[METADATA DEBUG] File does not exist (read failed)");
      }
      if (fileExists) {
        console.log("[METADATA DEBUG] Writing to existing file via adapter");
        await this.app.vault.adapter.write(this.METADATA_FILE_NAME, content);
        console.log("[METADATA DEBUG] File written successfully via adapter");
      } else {
        console.log("[METADATA DEBUG] Creating new file");
        try {
          await this.app.vault.create(this.METADATA_FILE_NAME, content);
          console.log("[METADATA DEBUG] File created successfully");
        } catch (createError) {
          console.log("[METADATA DEBUG] Create failed, trying direct write via adapter:", createError.message);
          try {
            await this.app.vault.adapter.write(this.METADATA_FILE_NAME, content);
            console.log("[METADATA DEBUG] Fallback write via adapter successful");
          } catch (writeError) {
            console.error("[METADATA DEBUG] All write attempts failed");
            throw createError;
          }
        }
      }
    } catch (error) {
      console.error("[METADATA DEBUG] Error saving Q&A pair metadata:", error);
      throw error;
    }
  }
  // Q&A pair management methods
  generateQAPairHash(userPrompt, response) {
    const content = JSON.stringify({
      userPrompt: userPrompt.substring(0, 200),
      response: response.substring(0, 200)
    });
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  generateQAPairId(conversationId, userMsgId, assistantMsgId) {
    return `${conversationId}_${userMsgId}_${assistantMsgId}`;
  }
  getQAPairState(pairId) {
    const metadata = this.metadataStore.qaPairs[pairId];
    return metadata ? metadata.state : "new" /* NEW */;
  }
  async updateQAPairState(pairId, state, conversationId, userPrompt, response) {
    const hash = this.generateQAPairHash(userPrompt, response);
    this.metadataStore.qaPairs[pairId] = {
      pairId,
      pairHash: hash,
      conversationId,
      state,
      timestamp: Date.now(),
      userPrompt: userPrompt.substring(0, 100),
      responsePreview: response.substring(0, 100)
    };
    await this.saveConversationMetadata();
  }
  // Get conversation processing status based on its Q&A pairs
  getConversationProcessingStatus(conversationId, totalAssistantMessages) {
    const pairs = Object.values(this.metadataStore.qaPairs).filter((pair) => pair.conversationId === conversationId);
    if (totalAssistantMessages === void 0) {
      if (pairs.length === 0) {
        return "unprocessed" /* UNPROCESSED */;
      }
      const newCount = pairs.filter((p) => p.state === "new" /* NEW */).length;
      return newCount === 0 ? "processed" /* PROCESSED */ : "partial" /* PARTIAL */;
    }
    const processedPairs = pairs.filter((p) => p.state !== "new" /* NEW */).length;
    const newPairs = pairs.filter((p) => p.state === "new" /* NEW */).length;
    const unprocessedPairs = totalAssistantMessages - pairs.length;
    const totalNewPairs = newPairs + unprocessedPairs;
    if (totalNewPairs === 0) {
      return "processed" /* PROCESSED */;
    } else if (processedPairs > 0) {
      return "partial" /* PARTIAL */;
    } else {
      return "unprocessed" /* UNPROCESSED */;
    }
  }
  getQAPairMetadata() {
    return this.metadataStore;
  }
};
var ChatGPTImportModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.conversations = [];
    this.currentConversationIndex = 0;
    this.viewMode = "toc";
    // Filter settings for TOC (conversation-level)
    this.showNew = true;
    this.showPartiallyProcessed = true;
    this.showFullyProcessed = false;
    // Filter settings for single conversation Q&A pairs
    this.showNewPairs = true;
    this.showIgnoredPairs = false;
    this.showSavedPairs = false;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Import ChatGPT Conversations" });
    const fileSection = contentEl.createDiv("file-section");
    fileSection.createEl("h3", { text: "Select conversations.json file" });
    const fileInput = fileSection.createEl("input", {
      type: "file",
      attr: { accept: ".json" }
    });
    const loadButton = fileSection.createEl("button", {
      text: "Load Conversations",
      cls: "mod-cta"
    });
    const conversationsDiv = contentEl.createDiv("conversations-section");
    conversationsDiv.style.display = "none";
    loadButton.onclick = () => {
      var _a;
      const file = (_a = fileInput.files) == null ? void 0 : _a[0];
      if (!file) {
        new import_obsidian.Notice("Please select a conversations.json file");
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        var _a2;
        try {
          const content = (_a2 = e.target) == null ? void 0 : _a2.result;
          const rawConversations = this.plugin.parseChatGPTData(content);
          this.conversations = this.plugin.extractConversations(rawConversations);
          this.displayConversations(conversationsDiv);
          conversationsDiv.style.display = "block";
          new import_obsidian.Notice(`Loaded ${this.conversations.length} conversations`);
        } catch (error) {
          new import_obsidian.Notice("Error loading ChatGPT data: " + error.message);
        }
      };
      reader.readAsText(file);
    };
  }
  displayConversations(container) {
    container.empty();
    if (this.viewMode === "toc") {
      this.displayTableOfContents(container);
    } else {
      this.displaySingleConversation(container);
    }
  }
  displayTableOfContents(container) {
    container.createEl("h3", { text: "Select a conversation to view" });
    const filtersDiv = container.createDiv("filter-controls");
    filtersDiv.style.cssText = "margin-bottom: 15px; padding: 10px; background: var(--background-secondary); border-radius: 8px; display: flex; gap: 15px; align-items: center;";
    filtersDiv.createEl("span", { text: "Show:", attr: { style: "font-weight: 500; margin-right: 5px;" } });
    const newLabel = filtersDiv.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 5px; cursor: pointer;" } });
    const newCheckbox = newLabel.createEl("input", {
      type: "checkbox"
    });
    newCheckbox.checked = this.showNew;
    newLabel.createEl("span", { text: "\u{1F195} New" });
    const partialLabel = filtersDiv.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 5px; cursor: pointer;" } });
    const partialCheckbox = partialLabel.createEl("input", {
      type: "checkbox"
    });
    partialCheckbox.checked = this.showPartiallyProcessed;
    partialLabel.createEl("span", { text: "\u{1F504} Partially Processed" });
    const fullyProcessedLabel = filtersDiv.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 5px; cursor: pointer;" } });
    const fullyProcessedCheckbox = fullyProcessedLabel.createEl("input", {
      type: "checkbox"
    });
    fullyProcessedCheckbox.checked = this.showFullyProcessed;
    fullyProcessedLabel.createEl("span", { text: "\u2705 Fully Processed" });
    newCheckbox.onchange = () => {
      this.showNew = newCheckbox.checked;
      this.displayConversations(container);
    };
    partialCheckbox.onchange = () => {
      this.showPartiallyProcessed = partialCheckbox.checked;
      this.displayConversations(container);
    };
    fullyProcessedCheckbox.onchange = () => {
      this.showFullyProcessed = fullyProcessedCheckbox.checked;
      this.displayConversations(container);
    };
    const filteredConversations = this.getFilteredConversations();
    const tocList = container.createDiv("toc-list");
    tocList.style.cssText = "max-height: 500px; overflow-y: auto; border: 1px solid var(--background-modifier-border); border-radius: 8px;";
    if (filteredConversations.length === 0) {
      const emptyMsg = tocList.createDiv("empty-message");
      emptyMsg.style.cssText = "padding: 20px; text-align: center; color: var(--text-muted);";
      emptyMsg.textContent = "No conversations match the current filter settings.";
      return;
    }
    filteredConversations.forEach((convWithIndex, filteredIndex) => {
      const conv = convWithIndex.conversation;
      const originalIndex = convWithIndex.originalIndex;
      const assistantMessagesCount = conv.messages.filter((msg) => msg.role === "assistant").length;
      const processingStatus = this.plugin.getConversationProcessingStatus(conv.id, assistantMessagesCount);
      const tocItem = tocList.createDiv("toc-item");
      tocItem.style.cssText = "padding: 15px; border-bottom: 1px solid var(--background-modifier-border); cursor: pointer; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center;";
      tocItem.addEventListener("mouseenter", () => {
        tocItem.style.backgroundColor = "var(--background-secondary)";
      });
      tocItem.addEventListener("mouseleave", () => {
        tocItem.style.backgroundColor = "";
      });
      const leftDiv = tocItem.createDiv();
      const titleRow = leftDiv.createEl("div");
      titleRow.style.cssText = "display: flex; align-items: center; gap: 8px; margin-bottom: 5px;";
      let stateEmoji = "";
      let stateColor = "";
      switch (processingStatus) {
        case "processed" /* PROCESSED */:
          stateEmoji = "\u2705";
          stateColor = "var(--color-green)";
          break;
        case "partial" /* PARTIAL */:
          stateEmoji = "\u{1F504}";
          stateColor = "var(--color-orange)";
          break;
        default:
          stateEmoji = "\u{1F195}";
          stateColor = "var(--interactive-accent)";
      }
      const stateIndicator = titleRow.createEl("span", { text: stateEmoji });
      stateIndicator.style.cssText = `color: ${stateColor}; font-size: 1.1em;`;
      const titleEl = titleRow.createEl("div");
      titleEl.textContent = conv.title;
      titleEl.style.cssText = "font-weight: 500; font-size: 1.05em; flex: 1;";
      const statsEl = leftDiv.createEl("div");
      const assistantMessages = conv.messages.filter((msg) => msg.role === "assistant");
      const statusText = processingStatus === "processed" /* PROCESSED */ ? "All processed" : processingStatus === "partial" /* PARTIAL */ ? "Partially processed" : "New";
      statsEl.textContent = `${assistantMessages.length} responses \u2022 ${statusText} \u2022 ${new Date(conv.create_time * 1e3).toLocaleDateString()}`;
      statsEl.style.cssText = "color: var(--text-muted); font-size: 0.9em;";
      const rightDiv = tocItem.createDiv();
      rightDiv.createEl("span", { text: "\u{1F441}\uFE0F View" });
      rightDiv.style.cssText = "color: var(--interactive-accent); font-size: 0.9em;";
      tocItem.onclick = () => {
        this.currentConversationIndex = originalIndex;
        this.viewMode = "conversation";
        this.displayConversations(container);
      };
    });
    const summaryDiv = container.createDiv("conversation-summary");
    summaryDiv.style.cssText = "margin-top: 10px; text-align: center; color: var(--text-muted); font-size: 0.9em;";
    const total = this.conversations.length;
    const showing = filteredConversations.length;
    summaryDiv.textContent = showing === total ? `Showing all ${total} conversations` : `Showing ${showing} of ${total} conversations`;
  }
  getFilteredConversations() {
    return this.conversations.map((conv, index) => ({ conversation: conv, originalIndex: index })).filter(({ conversation }) => {
      const assistantMessagesCount = conversation.messages.filter((msg) => msg.role === "assistant").length;
      const processingStatus = this.plugin.getConversationProcessingStatus(conversation.id, assistantMessagesCount);
      switch (processingStatus) {
        case "unprocessed" /* UNPROCESSED */:
          return this.showNew;
        case "partial" /* PARTIAL */:
          return this.showPartiallyProcessed;
        case "processed" /* PROCESSED */:
          return this.showFullyProcessed;
        default:
          return this.showNew;
      }
    });
  }
  displaySingleConversation(container) {
    if (this.conversations.length === 0) return;
    const conv = this.conversations[this.currentConversationIndex];
    if (!conv) return;
    const assistantMessages = conv.messages.filter((msg) => msg.role === "assistant");
    const processingStatus = this.plugin.getConversationProcessingStatus(conv.id, assistantMessages.length);
    const header = container.createDiv("conversation-header");
    header.style.cssText = "margin-bottom: 15px; padding: 12px; background: var(--background-secondary); border-radius: 6px; border: 1px solid var(--background-modifier-border);";
    const titleRow = header.createDiv();
    titleRow.style.cssText = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;";
    const titleInfo = titleRow.createDiv();
    titleInfo.style.cssText = "display: flex; align-items: center; gap: 10px;";
    let stateEmoji = "";
    let stateColor = "";
    let statusText = "";
    switch (processingStatus) {
      case "processed" /* PROCESSED */:
        stateEmoji = "\u2705";
        stateColor = "var(--color-green)";
        statusText = "All processed";
        break;
      case "partial" /* PARTIAL */:
        stateEmoji = "\u{1F504}";
        stateColor = "var(--color-orange)";
        statusText = "Partially processed";
        break;
      default:
        stateEmoji = "\u{1F195}";
        stateColor = "var(--interactive-accent)";
        statusText = "New";
    }
    const stateIndicator = titleInfo.createEl("span", { text: stateEmoji });
    stateIndicator.style.cssText = `color: ${stateColor}; font-size: 1.1em;`;
    const titleEl = titleInfo.createEl("div");
    titleEl.textContent = conv.title;
    titleEl.style.cssText = "font-weight: 500; font-size: 1.1em;";
    const backButton = titleRow.createEl("button", {
      text: "\u{1F4CB} Back",
      cls: "mod-muted"
    });
    backButton.style.cssText = "font-size: 0.9em;";
    backButton.onclick = () => {
      this.viewMode = "toc";
      this.displayConversations(container);
    };
    const statsRow = header.createDiv();
    statsRow.style.cssText = "display: flex; justify-content: space-between; align-items: center; color: var(--text-muted); font-size: 0.9em;";
    const statsText = statsRow.createDiv();
    statsText.textContent = `Conversation ${this.currentConversationIndex + 1} of ${this.conversations.length} \u2022 ${assistantMessages.length} responses \u2022 ${statusText} \u2022 ${new Date(conv.create_time * 1e3).toLocaleDateString()}`;
    const nav = statsRow.createDiv();
    nav.style.cssText = "display: flex; gap: 5px;";
    const prevButton = nav.createEl("button", {
      text: "\u2039",
      attr: { title: "Previous conversation" }
    });
    prevButton.style.cssText = "width: 24px; height: 24px; padding: 0; font-size: 16px;";
    prevButton.disabled = this.currentConversationIndex === 0;
    prevButton.onclick = () => {
      if (this.currentConversationIndex > 0) {
        this.currentConversationIndex--;
        this.displayConversations(container);
      }
    };
    const nextButton = nav.createEl("button", {
      text: "\u203A",
      attr: { title: "Next conversation" }
    });
    nextButton.style.cssText = "width: 24px; height: 24px; padding: 0; font-size: 16px;";
    nextButton.disabled = this.currentConversationIndex === this.conversations.length - 1;
    nextButton.onclick = () => {
      if (this.currentConversationIndex < this.conversations.length - 1) {
        this.currentConversationIndex++;
        this.displayConversations(container);
      }
    };
    const pairFiltersDiv = container.createDiv("pair-filter-controls");
    pairFiltersDiv.style.cssText = "margin-bottom: 10px; padding: 8px 12px; background: var(--background-secondary); border-radius: 6px; border: 1px solid var(--background-modifier-border);";
    const filterHeader = pairFiltersDiv.createEl("div");
    filterHeader.style.cssText = "display: flex; align-items: center; gap: 12px; flex-wrap: wrap;";
    filterHeader.createEl("span", { text: "Show:", attr: { style: "font-weight: 500; color: var(--text-normal); font-size: 0.9em;" } });
    const newPairsLabel = filterHeader.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9em;" } });
    const newPairsCheckbox = newPairsLabel.createEl("input", {
      type: "checkbox"
    });
    newPairsCheckbox.checked = this.showNewPairs;
    newPairsLabel.createEl("span", { text: "\u{1F195} New" });
    const ignoredPairsLabel = filterHeader.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9em;" } });
    const ignoredPairsCheckbox = ignoredPairsLabel.createEl("input", {
      type: "checkbox"
    });
    ignoredPairsCheckbox.checked = this.showIgnoredPairs;
    ignoredPairsLabel.createEl("span", { text: "\u{1F6AB} Ignored" });
    const savedPairsLabel = filterHeader.createEl("label", { attr: { style: "display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.9em;" } });
    const savedPairsCheckbox = savedPairsLabel.createEl("input", {
      type: "checkbox"
    });
    savedPairsCheckbox.checked = this.showSavedPairs;
    savedPairsLabel.createEl("span", { text: "\u2705 Saved" });
    newPairsCheckbox.onchange = () => {
      this.showNewPairs = newPairsCheckbox.checked;
      this.displayConversations(container);
    };
    ignoredPairsCheckbox.onchange = () => {
      this.showIgnoredPairs = ignoredPairsCheckbox.checked;
      this.displayConversations(container);
    };
    savedPairsCheckbox.onchange = () => {
      this.showSavedPairs = savedPairsCheckbox.checked;
      this.displayConversations(container);
    };
    const contentDiv = container.createDiv("single-conversation-content");
    contentDiv.style.cssText = "border: 1px solid var(--background-modifier-border); border-radius: 6px; padding: 12px; max-height: calc(100vh - 280px); overflow-y: auto;";
    const filteredPairs = this.getFilteredQAPairs(conv, assistantMessages);
    if (filteredPairs.length < assistantMessages.length) {
      const filterStatus = contentDiv.createDiv("filter-status");
      filterStatus.style.cssText = "margin-bottom: 10px; padding: 6px 10px; background: var(--background-primary); border: 1px solid var(--color-orange); border-radius: 4px; text-align: center; color: var(--color-orange); font-size: 0.85em;";
      filterStatus.textContent = `Showing ${filteredPairs.length} of ${assistantMessages.length} pairs (${assistantMessages.length - filteredPairs.length} filtered)`;
    }
    if (filteredPairs.length === 0) {
      const emptyState = contentDiv.createDiv("empty-pairs");
      emptyState.style.cssText = "padding: 40px; text-align: center; color: var(--text-muted);";
      emptyState.innerHTML = `
				<div style="font-size: 1.2em; margin-bottom: 10px;">\u{1F50D}</div>
				<div style="font-weight: 500; margin-bottom: 5px;">No Q&A pairs match your filters</div>
				<div style="font-size: 0.9em;">Adjust the filter settings above to see more pairs</div>
			`;
      return;
    }
    filteredPairs.forEach((assistantMsg, msgIndex) => {
      const messageIndex = conv.messages.findIndex((msg) => msg.id === assistantMsg.id);
      const userMsg = messageIndex > 0 ? conv.messages[messageIndex - 1] : null;
      const userMsgId = userMsg ? userMsg.id : "no-user-msg";
      const pairId = this.plugin.generateQAPairId(conv.id, userMsgId, assistantMsg.id);
      const pairState = this.plugin.getQAPairState(pairId);
      console.log(`[QA PAIR DEBUG] Pair ${msgIndex + 1}:`, {
        conversationId: conv.id,
        userMsgId,
        assistantMsgId: assistantMsg.id,
        generatedPairId: pairId,
        lookedUpState: pairState,
        metadataKeys: Object.keys(this.plugin.getQAPairMetadata().qaPairs)
      });
      let borderColor = "var(--interactive-accent)";
      let stateEmoji2 = "";
      let stateColor2 = "";
      let stateText = "";
      switch (pairState) {
        case "saved" /* SAVED */:
          borderColor = "var(--color-green)";
          stateEmoji2 = "\u2705";
          stateColor2 = "var(--color-green)";
          stateText = "Saved";
          break;
        case "ignored" /* IGNORED */:
          borderColor = "var(--text-muted)";
          stateEmoji2 = "\u{1F6AB}";
          stateColor2 = "var(--text-muted)";
          stateText = "Ignored";
          break;
        default:
          borderColor = "var(--interactive-accent)";
          stateEmoji2 = "\u{1F195}";
          stateColor2 = "var(--interactive-accent)";
          stateText = "New";
      }
      const qaDiv = contentDiv.createDiv("qa-pair");
      qaDiv.style.cssText = `margin: 20px 0; padding: 20px; background: var(--background-secondary); border-radius: 8px; border-left: 4px solid ${borderColor};`;
      const pairHeader = qaDiv.createEl("div");
      pairHeader.style.cssText = "display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--background-modifier-border);";
      const pairTitle = pairHeader.createEl("div");
      pairTitle.style.cssText = "font-weight: 500; color: var(--text-normal);";
      pairTitle.textContent = `Q&A Pair ${msgIndex + 1}`;
      const stateIndicator2 = pairHeader.createEl("div");
      stateIndicator2.style.cssText = `display: flex; align-items: center; gap: 5px; padding: 4px 8px; border-radius: 12px; background: ${stateColor2}20; color: ${stateColor2}; font-size: 0.85em; font-weight: 500;`;
      stateIndicator2.createEl("span", { text: stateEmoji2 });
      stateIndicator2.createEl("span", { text: stateText });
      if (userMsg && userMsg.role === "user") {
        const promptHeader = qaDiv.createEl("div");
        promptHeader.style.cssText = "margin-bottom: 12px;";
        const promptLabel = promptHeader.createEl("strong", { text: "\u2753 User Prompt:" });
        promptLabel.style.cssText = "color: var(--text-accent); font-size: 0.95em; margin-bottom: 8px; display: block;";
        const promptDiv = qaDiv.createEl("div");
        promptDiv.style.cssText = "padding: 12px; background: var(--background-primary); border-radius: 6px; margin-bottom: 18px; border-left: 3px solid var(--text-accent);";
        promptDiv.innerHTML = this.formatMessageContent(userMsg.content);
      }
      const responseHeader = qaDiv.createEl("div");
      responseHeader.style.cssText = "margin-bottom: 12px;";
      const responseLabel = responseHeader.createEl("strong", { text: "\u{1F916} ChatGPT Response:" });
      responseLabel.style.cssText = "color: var(--interactive-accent); font-size: 0.95em; margin-bottom: 8px; display: block;";
      const responseDiv = qaDiv.createEl("div");
      responseDiv.style.cssText = "padding: 15px; background: var(--background-primary); border-radius: 6px; margin-bottom: 15px; line-height: 1.6; border: 1px solid var(--background-modifier-border);";
      responseDiv.innerHTML = this.formatMessageContent(assistantMsg.content);
      const buttonDiv = qaDiv.createEl("div");
      buttonDiv.style.cssText = "display: flex; gap: 10px; margin-top: 15px;";
      if (pairState === "new" /* NEW */) {
        const saveButton = buttonDiv.createEl("button", {
          text: "\u{1F4BE} Save as Note",
          cls: "mod-cta"
        });
        saveButton.style.cssText = "flex: 1;";
        const ignoreButton = buttonDiv.createEl("button", {
          text: "\u{1F6AB} Ignore"
        });
        ignoreButton.style.cssText = "flex: 1;";
        saveButton.onclick = () => {
          const modal = new SaveNoteModal(this.app, this.plugin, conv, assistantMsg, userMsg, pairId, () => {
            this.displayConversations(container);
          });
          modal.open();
        };
        ignoreButton.onclick = async () => {
          const confirmed = confirm("Mark this Q&A pair as ignored?");
          if (confirmed) {
            const userPrompt = userMsg ? userMsg.content : "";
            await this.plugin.updateQAPairState(pairId, "ignored" /* IGNORED */, conv.id, userPrompt, assistantMsg.content);
            this.displayConversations(container);
            new import_obsidian.Notice("Q&A pair marked as ignored.");
          }
        };
      } else if (pairState === "saved" /* SAVED */) {
        const resaveButton = buttonDiv.createEl("button", {
          text: "\u{1F4BE} Save Again"
        });
        resaveButton.style.cssText = "flex: 1;";
        const resetButton = buttonDiv.createEl("button", {
          text: "\u21A9\uFE0F Reset to New"
        });
        resetButton.style.cssText = "flex: 1;";
        resaveButton.onclick = () => {
          const modal = new SaveNoteModal(this.app, this.plugin, conv, assistantMsg, userMsg, pairId, () => {
            this.displayConversations(container);
          });
          modal.open();
        };
        resetButton.onclick = async () => {
          const confirmed = confirm("Reset this Q&A pair to new status?");
          if (confirmed) {
            const userPrompt = userMsg ? userMsg.content : "";
            await this.plugin.updateQAPairState(pairId, "new" /* NEW */, conv.id, userPrompt, assistantMsg.content);
            this.displayConversations(container);
            new import_obsidian.Notice("Q&A pair reset to new status.");
          }
        };
      } else if (pairState === "ignored" /* IGNORED */) {
        const saveButton = buttonDiv.createEl("button", {
          text: "\u{1F4BE} Save as Note",
          cls: "mod-cta"
        });
        saveButton.style.cssText = "flex: 1;";
        const unignoreButton = buttonDiv.createEl("button", {
          text: "\u21A9\uFE0F Un-ignore"
        });
        unignoreButton.style.cssText = "flex: 1;";
        saveButton.onclick = () => {
          const modal = new SaveNoteModal(this.app, this.plugin, conv, assistantMsg, userMsg, pairId, () => {
            this.displayConversations(container);
          });
          modal.open();
        };
        unignoreButton.onclick = async () => {
          const confirmed = confirm("Reset this Q&A pair to new status?");
          if (confirmed) {
            const userPrompt = userMsg ? userMsg.content : "";
            await this.plugin.updateQAPairState(pairId, "new" /* NEW */, conv.id, userPrompt, assistantMsg.content);
            this.displayConversations(container);
            new import_obsidian.Notice("Q&A pair reset to new status.");
          }
        };
      }
    });
  }
  // Get filtered Q&A pairs based on current filter settings
  getFilteredQAPairs(conv, assistantMessages) {
    return assistantMessages.filter((assistantMsg) => {
      const messageIndex = conv.messages.findIndex((msg) => msg.id === assistantMsg.id);
      const userMsg = messageIndex > 0 ? conv.messages[messageIndex - 1] : null;
      const userMsgId = userMsg ? userMsg.id : "no-user-msg";
      const pairId = this.plugin.generateQAPairId(conv.id, userMsgId, assistantMsg.id);
      const pairState = this.plugin.getQAPairState(pairId);
      switch (pairState) {
        case "new" /* NEW */:
          return this.showNewPairs;
        case "ignored" /* IGNORED */:
          return this.showIgnoredPairs;
        case "saved" /* SAVED */:
          return this.showSavedPairs;
        default:
          return this.showNewPairs;
      }
    });
  }
  // Format message content for better display
  formatMessageContent(content) {
    let formatted = content.replace(/```([\s\S]*?)```/g, '<pre style="background: var(--background-secondary); padding: 8px; border-radius: 4px; overflow-x: auto; margin: 8px 0; border: 1px solid var(--background-modifier-border);"><code>$1</code></pre>').replace(/`([^`]+)`/g, '<code style="background: var(--background-secondary); padding: 2px 4px; border-radius: 3px; font-family: var(--font-monospace);">$1</code>').replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>").replace(/\*(.*?)\*/g, "<em>$1</em>").replace(/\n/g, "<br>").replace(/^- (.+)/gm, '<li style="margin-left: 20px;">$1</li>').replace(/^\d+\. (.+)/gm, '<li style="margin-left: 20px; list-style-type: decimal;">$1</li>');
    formatted = formatted.replace(/(<li[^>]*>.*?<\/li>(?:<br>)?)+/g, (match) => {
      return '<ul style="margin: 8px 0; padding-left: 0;">' + match.replace(/<br>/g, "") + "</ul>";
    });
    return formatted;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SaveNoteModal = class extends import_obsidian.Modal {
  constructor(app, plugin, conversation, message, userMessage, pairId, onSaveCallback) {
    super(app);
    this.saveInProgress = false;
    this.plugin = plugin;
    this.conversation = conversation;
    this.message = message;
    this.userMessage = userMessage;
    this.pairId = pairId;
    this.onSaveCallback = onSaveCallback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Save ChatGPT Response as Note" });
    const titleDiv = contentEl.createDiv();
    titleDiv.createEl("label", { text: "Note Title:" });
    const titleInput = titleDiv.createEl("input", {
      type: "text",
      value: `${this.conversation.title} - Response`,
      attr: { style: "width: 100%; margin: 5px 0;" }
    });
    const folderDiv = contentEl.createDiv();
    folderDiv.createEl("label", { text: "Save to folder:" });
    const folderSelectContainer = folderDiv.createDiv();
    folderSelectContainer.style.cssText = "position: relative; width: 100%; margin: 5px 0;";
    const folderInput = folderSelectContainer.createEl("input", {
      type: "text",
      value: this.plugin.settings.defaultFolder,
      attr: {
        style: "width: 100%; padding: 8px; padding-right: 30px; border: 1px solid var(--background-modifier-border); border-radius: 4px; background: var(--background-primary);",
        placeholder: "Type folder path or select from dropdown..."
      }
    });
    const dropdownButton = folderSelectContainer.createEl("button", {
      text: "\u25BC",
      attr: {
        type: "button",
        style: "position: absolute; right: 5px; top: 50%; transform: translateY(-50%); border: none; background: none; cursor: pointer; color: var(--text-muted); font-size: 12px; padding: 2px 4px;"
      }
    });
    const dropdownList = folderSelectContainer.createEl("div");
    dropdownList.style.cssText = "position: absolute; top: 100%; left: 0; right: 0; background: var(--background-primary); border: 1px solid var(--background-modifier-border); border-top: none; border-radius: 0 0 4px 4px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none;";
    const getAllFolders = () => {
      const folders = [""];
      const allFiles = this.app.vault.getAllLoadedFiles();
      allFiles.forEach((file) => {
        if (file instanceof import_obsidian.TFolder) {
          folders.push(file.path);
        }
      });
      return folders.sort();
    };
    const populateDropdown = (filter = "") => {
      dropdownList.empty();
      const folders = getAllFolders();
      const filteredFolders = folders.filter(
        (folder) => folder.toLowerCase().includes(filter.toLowerCase())
      );
      if (filteredFolders.length === 0) {
        const noResults = dropdownList.createEl("div");
        noResults.textContent = filter ? `No folders match "${filter}"` : "No folders found";
        noResults.style.cssText = "padding: 8px 12px; color: var(--text-muted); font-style: italic;";
        return;
      }
      filteredFolders.forEach((folder) => {
        const option = dropdownList.createEl("div");
        option.textContent = folder || "(Root folder)";
        option.style.cssText = "padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border-hover); transition: background-color 0.1s;";
        if (filter && folder.toLowerCase().includes(filter.toLowerCase())) {
          const regex = new RegExp(`(${filter})`, "gi");
          const displayText = folder || "(Root folder)";
          option.innerHTML = displayText.replace(regex, '<mark style="background: var(--text-selection); padding: 0;">$1</mark>');
        }
        option.addEventListener("mouseenter", () => {
          option.style.backgroundColor = "var(--background-modifier-hover)";
        });
        option.addEventListener("mouseleave", () => {
          option.style.backgroundColor = "";
        });
        option.onclick = () => {
          folderInput.value = folder;
          dropdownList.style.display = "none";
          updatePreview();
        };
      });
      if (filter && !filteredFolders.includes(filter) && filter.trim() !== "") {
        const createOption = dropdownList.createEl("div");
        createOption.innerHTML = `<span style="color: var(--interactive-accent);">\u{1F4C1} Create folder: "${filter}"</span>`;
        createOption.style.cssText = "padding: 8px 12px; cursor: pointer; border-top: 1px solid var(--background-modifier-border); background: var(--background-secondary); font-weight: 500;";
        createOption.addEventListener("mouseenter", () => {
          createOption.style.backgroundColor = "var(--background-modifier-hover)";
        });
        createOption.addEventListener("mouseleave", () => {
          createOption.style.backgroundColor = "var(--background-secondary)";
        });
        createOption.onclick = () => {
          folderInput.value = filter;
          dropdownList.style.display = "none";
          updatePreview();
        };
      }
    };
    const toggleDropdown = () => {
      if (dropdownList.style.display === "none" || !dropdownList.style.display) {
        populateDropdown(folderInput.value);
        dropdownList.style.display = "block";
      } else {
        dropdownList.style.display = "none";
      }
    };
    dropdownButton.onclick = (e) => {
      e.preventDefault();
      toggleDropdown();
    };
    folderInput.onfocus = () => {
      populateDropdown(folderInput.value);
      dropdownList.style.display = "block";
    };
    folderInput.oninput = () => {
      if (dropdownList.style.display === "block") {
        populateDropdown(folderInput.value);
      }
      updatePreview();
    };
    folderInput.onkeydown = (e) => {
      const options = Array.from(dropdownList.children);
      const visibleOptions = options.filter((opt) => opt.style.display !== "none");
      if (e.key === "ArrowDown" && dropdownList.style.display === "block") {
        e.preventDefault();
        if (visibleOptions.length > 0) {
          visibleOptions[0].focus();
        }
      } else if (e.key === "Escape") {
        dropdownList.style.display = "none";
      } else if (e.key === "Enter" && dropdownList.style.display === "block") {
        e.preventDefault();
        dropdownList.style.display = "none";
      }
    };
    document.addEventListener("click", (e) => {
      if (!folderSelectContainer.contains(e.target)) {
        dropdownList.style.display = "none";
      }
    });
    const tagsDiv = contentEl.createDiv();
    tagsDiv.createEl("label", { text: "Tags (comma-separated):" });
    const tagsInput = tagsDiv.createEl("input", {
      type: "text",
      value: this.plugin.settings.defaultTags,
      attr: { style: "width: 100%; margin: 5px 0;" }
    });
    const previewDiv = contentEl.createDiv();
    previewDiv.createEl("h4", { text: "Preview:" });
    const previewEl = previewDiv.createEl("pre");
    previewEl.style.cssText = "background: var(--background-secondary); padding: 10px; border-radius: 5px; white-space: pre-wrap; max-height: 300px; overflow-y: auto;";
    const updatePreview = () => {
      const content = this.generateNoteContent(
        titleInput.value,
        tagsInput.value
      );
      previewEl.textContent = content;
    };
    titleInput.oninput = updatePreview;
    tagsInput.oninput = updatePreview;
    updatePreview();
    const buttonDiv = contentEl.createDiv();
    buttonDiv.style.cssText = "display: flex; gap: 10px; margin-top: 20px;";
    const saveButton = buttonDiv.createEl("button", {
      text: "Save Note",
      cls: "mod-cta"
    });
    const cancelButton = buttonDiv.createEl("button", {
      text: "Cancel"
    });
    saveButton.onclick = async () => {
      if (saveButton.disabled) return;
      saveButton.disabled = true;
      saveButton.textContent = "Saving...";
      try {
        await this.saveNote(
          titleInput.value,
          folderInput.value,
          tagsInput.value
        );
        new import_obsidian.Notice("Note saved successfully!");
        if (this.onSaveCallback) {
          this.onSaveCallback();
        }
        this.close();
      } catch (error) {
        new import_obsidian.Notice("Error saving note: " + error.message);
        saveButton.disabled = false;
        saveButton.textContent = "Save Note";
      }
    };
    cancelButton.onclick = () => {
      this.close();
    };
  }
  generateNoteContent(title, tags) {
    const tagArray = tags.split(",").map((t) => t.trim()).filter((t) => t);
    const timestamp = new Date(this.message.timestamp * 1e3).toISOString().split("T")[0];
    let content = "";
    content += "---\n";
    content += `title: "${title}"
`;
    if (tagArray.length > 0) {
      content += `tags: [${tagArray.map((t) => `"${t}"`).join(", ")}]
`;
    }
    if (this.plugin.settings.includeTimestamps) {
      content += `created: ${timestamp}
`;
      content += `source: ChatGPT
`;
      content += `conversation: "${this.conversation.title}"
`;
    }
    content += "---\n\n";
    if (this.plugin.settings.includeUserPrompts) {
      const messageIndex = this.conversation.messages.findIndex((msg) => msg.id === this.message.id);
      if (messageIndex > 0) {
        const userMessage = this.conversation.messages[messageIndex - 1];
        if (userMessage.role === "user") {
          content += "## User Prompt\n\n";
          content += convertToMarkdown(userMessage.content) + "\n\n";
        }
      }
    }
    content += "## Response\n\n";
    content += convertToMarkdown(this.message.content);
    return content;
  }
  async saveNote(title, folder, tags) {
    console.log("[SAVE DEBUG] Starting save operation:", { title, folder, tags, pairId: this.pairId });
    if (this.saveInProgress) {
      console.log("[SAVE DEBUG] Save already in progress, throwing error");
      throw new Error("Save operation already in progress");
    }
    this.saveInProgress = true;
    console.log("[SAVE DEBUG] Set saveInProgress = true");
    let createdFilePath = null;
    try {
      const content = this.generateNoteContent(title, tags);
      const folderPath = folder.trim();
      if (folderPath && !this.app.vault.getAbstractFileByPath(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const safeTitle = title.replace(/[\\/:*?"<>|]/g, "-");
      let finalPath = folderPath ? `${folderPath}/${safeTitle}.md` : `${safeTitle}.md`;
      let counter = 1;
      const maxRetries = 100;
      let fileCreated = false;
      const basePath = finalPath;
      while (this.app.vault.getAbstractFileByPath(finalPath)) {
        const lastSlashIndex = basePath.lastIndexOf("/");
        const dir = lastSlashIndex >= 0 ? basePath.substring(0, lastSlashIndex + 1) : "";
        const nameWithExt = lastSlashIndex >= 0 ? basePath.substring(lastSlashIndex + 1) : basePath;
        const lastDotIndex = nameWithExt.lastIndexOf(".");
        const name = lastDotIndex >= 0 ? nameWithExt.substring(0, lastDotIndex) : nameWithExt;
        const ext = lastDotIndex >= 0 ? nameWithExt.substring(lastDotIndex) : "";
        finalPath = `${dir}${name} (${counter})${ext}`;
        counter++;
        if (counter > maxRetries) {
          throw new Error(`Too many duplicate files. Unable to create unique filename after ${maxRetries} attempts.`);
        }
      }
      console.log("[SAVE DEBUG] Attempting to create file:", finalPath);
      try {
        await this.app.vault.create(finalPath, content);
        createdFilePath = finalPath;
        fileCreated = true;
        console.log("[SAVE DEBUG] File created successfully:", finalPath);
      } catch (error) {
        console.log("[SAVE DEBUG] File creation failed:", error.message);
        const timestampSuffix = Date.now().toString();
        const lastSlashIndex = basePath.lastIndexOf("/");
        const dir = lastSlashIndex >= 0 ? basePath.substring(0, lastSlashIndex + 1) : "";
        const nameWithExt = lastSlashIndex >= 0 ? basePath.substring(lastSlashIndex + 1) : basePath;
        const lastDotIndex = nameWithExt.lastIndexOf(".");
        const name = lastDotIndex >= 0 ? nameWithExt.substring(0, lastDotIndex) : nameWithExt;
        const ext = lastDotIndex >= 0 ? nameWithExt.substring(lastDotIndex) : "";
        const fallbackPath = `${dir}${name}-${timestampSuffix}${ext}`;
        try {
          await this.app.vault.create(fallbackPath, content);
          createdFilePath = fallbackPath;
          fileCreated = true;
        } catch (fallbackError) {
          throw error;
        }
      }
      if (!fileCreated) {
        throw new Error("Failed to create file");
      }
      if (this.pairId) {
        console.log("[SAVE DEBUG] Updating Q&A pair state for:", this.pairId);
        try {
          const userPrompt = this.userMessage ? this.userMessage.content : "";
          await this.plugin.updateQAPairState(this.pairId, "saved" /* SAVED */, this.conversation.id, userPrompt, this.message.content);
          console.log("[SAVE DEBUG] Q&A pair state updated successfully");
        } catch (metadataError) {
          console.error("[SAVE DEBUG] Failed to update Q&A pair metadata:", metadataError);
        }
      } else {
        console.log("[SAVE DEBUG] No pairId provided, skipping metadata update");
      }
    } finally {
      this.saveInProgress = false;
      console.log("[SAVE DEBUG] Save operation completed, set saveInProgress = false");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChatGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ChatGPT to Obsidian Settings" });
    new import_obsidian.Setting(containerEl).setName("Default folder").setDesc("Default folder to save ChatGPT notes").addText((text) => text.setPlaceholder("ChatGPT").setValue(this.plugin.settings.defaultFolder).onChange(async (value) => {
      this.plugin.settings.defaultFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include user prompts").setDesc("Include the user prompt that generated the response").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeUserPrompts).onChange(async (value) => {
      this.plugin.settings.includeUserPrompts = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include timestamps").setDesc("Include creation timestamps in note metadata").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTimestamps).onChange(async (value) => {
      this.plugin.settings.includeTimestamps = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default tags").setDesc("Default tags to add to ChatGPT notes (comma-separated)").addText((text) => text.setPlaceholder("chatgpt, ai").setValue(this.plugin.settings.defaultTags).onChange(async (value) => {
      this.plugin.settings.defaultTags = value;
      await this.plugin.saveSettings();
    }));
  }
};
